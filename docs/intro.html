<HTML>

<HEAD>
<TITLE>How to use libMaTcl</TITLE>
</HEAD>

<body>

<CENTER>
<H3>
libMaTcl を用いたTcl/Tkの拡張
</H3>
</CENTER>

<H4>
はじめに
</H4>

Tclはもともとアプリケーションの制御用インタプリタとして開発されたため，
ユーザが独自のコマンドを追加するためのC言語APIを持っている．
しかし，このインターフェイスは以下のような欠点を持っている．

<UL>
<LI>
実際には書き換えられることのない文字列へのポインタが char * で宣言され
ているため，const char * の文字列を渡すことができない．
キャストで誤魔化せばいいけど気持が悪い．また，現在のソースでは書き換え
られる心配がなくても将来にわたってその仕様が保たれるかの保証がない．

<LI>
<A HREF="#cmdproc">コマンドプロシージャ</A>や
<A HREF="#trace">変数トレースコールバック</A>
で任意のデータを渡せるようにするために，
void *型の引数を渡すようになっている．
これではユーザが常に型の整合性を保つように努力しなければならない．

<LI>
Tcl8.0以降のバージョンでは，
Tclの扱うデータ(Tclスクリプトそのものも含む)の内部表現を文字列(char *)
から<A HREF="#Tcl_Obj">Tcl_Obj</A>という構造体に変更している．
このTcl_Objのオブジェクト自身は参照回数のカウンタを持っており，
無駄なコピーを行わないなどの効率化がなされているが，
この参照回数を正しく保つのはユーザの責任となっている．

</UL>

このように，Tcl固有のAPIはCの設計思想と同様に，
「プログラマが責任を持って気をつけて書けばなんだってできるよ」というこ
となので，ちょっとでも気を抜くとバグが入ってしまう作りになっている．
これに対して，最近の流行りはC++の設計思想の様に，
「素人さんにはこれだけの操作しか許しません」とある程度書ける範囲を限定
して(もちろん機能的なロスはなしで)安全性を高める作りになっている．
libMaTcl はそのような目的で作られたクラスライブラリで，
Tcl/Tkを機能的なロスやオーバーヘッドなしに安全に拡張するための手段を提
供している．

<H4>
libMaTclの構成
</H4>

libMaTclは次のようなクラスからなる．

<DL>
<DT><A HREF="#hf_CTclBase">hf_CTclBase</A>
<DD>
<P>
<A HREF="#Tcl_Interp">Tclインタプリタ</A>へのポインタを持ったクラス．
TclのほとんどすべてのAPI関数のwrapper関数をメンバ関数として持つ．
libMaTclの他のクラスの基底クラスとなっている．
抽象的な意味としては前述の様にTclインタプリタへのポインタを持ったクラ
スであってTclインタプリタがC++的に進化したものではない．
より具体的には，一つのTclインタプリタに対して，複数のhf_CTclBaseオブジェ
クトが存在し得るということ．
</P>

<DT><A HREF="#hf_CTclObjPtr">hf_CTclObjPtr</A>
<DD>
<P>
<A HREF="#Tcl_Obj">Tcl_Obj</A>へのポインタを持ったクラス．
Tclインタプリタに次いで重要なデータ構造であるTcl_Objに対するwrapperク
ラス．こちらもTcl_Objそのものではなく，Tcl_Objへのポインタを抽象化した
クラスである．さまざまなデータ型と文字列との変換や文字列型データの操作，
リスト型データの操作などの処理を行うメンバ関数を持つ．
理想的にはユーザ定義のデータ型との変換もこのクラスに対する継承という形
でできることが望ましいが，Tcl上では新しいデータ型の追加がダイナミック
にできてしまう(要する登録関数を呼べば良い)ので，クラスの継承というスタ
ティックなやり方では対応が難しい．
</P>

<DT><A HREF="#hf_CTclCmd">hf_CTclCmd</A>
<DD>
<P>
<A HREF="#cmdproc">コマンドプロシージャ</A>がC++的に進化したもの．
ユーザが定義するデータはこのクラスの継承クラスのメンバ変数として定義す
れば良い．また，Tclインタプリタに渡す真のコマンドプロシージャは
libMaTclに作り付けの関数であり，そこからこのクラスのメンバ関数が起動さ
れる．そのため，ユーザは void *からのキャストする操作を行う必要がなく，
常に安全なコードを書くことができる．
</P>

<DT><A HREF="#hf_CTclCmdCls">hf_CTclCmdCls</A>
<DD>
<P>
<A HREF="#hf_CTclCmd">hf_CTclCmd</A>を継承した派生クラス.
同時にhf_CTclCmdのオブジェクトを生成し，Tclコマンド
に結びつけるコマンドを実行するクラスでもある．
これはTkのウィジェットのようなオブジェクト指向タイプのコマンドオブジェ
クトを生成するために用いられる．
</P>

<DT><A HREF="#hf_CTclVarTrace">hf_CTclVarTrace</A>
<DD>
<P>
<A HREF="#trace">変数トレースコールバック</A>とclientDataを併せて
C++的に進化させたもの．
ユーザはこのクラスを継承したクラス上にメンバ変数を定義することで安全に
自分の定義したデータを用いることができる．
hf_CTclCmdの場合と同じように真のトレースコールバックはlibMaTclに作り付
けの関数であり，そこからこのクラスのメンバ関数が起動される．
</P>

</DL>

<HR>

<H4>
Glossary
</H4>

<DL>
<DT><A NAME="Tcl_Interp"><Tclインタプリタ</A>
<DD>
<P>
Tclの本体．Tclの変数やプロシージャ等はすべてこのインタプリタ上に存在す
ると考えて良い．また，コマンドの実行結果やエラー情報などを格納する
場所を持っているのもこのインタプリタである．
ほとんどすべてのTclのC言語API関数の第一引数として与える必要がある．
通常は一つのアプリケーションでインタプリタは一つだが，
複数のインタプリタを持ったアプリケーションを作ることも可能．
</P>

<DT><A NAME="Tcl_Obj">Tcl_Obj</A>
<DD>
<P>
Tclのデータを表す構造体．表の顔として文字列を持つが，裏の顔として
int,long,double,リスト，ブール値，コンパイルされたTclスクリプト
などのデータ構造を持つ．
必要に応じて異なるデータ構造に変換されるが，いずれの場合も文字列に変換
可能勝つ，文字列から変換可能でなければならない．
<A HREF="#Tcl_ObjType">Tcl_ObjType</A>という構造体を用いたユーザ定義の
新たなデータ構造を持たせることも可能．
Tcl_Objは参照回数を表すカウンタを持っており，この回数が0になると自動的
に削除される．また，複数からの参照を持っているTcl_Objの内容を変える処
理はエラーとなる．
</P>

<DT><A NAME="Tcl_ObjType">Tcl_ObjType</A>
<DD>
<P>
Tcl_Objに新しいデータ構造を持たせるための情報を保持する構造体．
具体的には，

<UL>
<LI>データ構造の名前
<LI>削除するための関数
<LI>複製を作るための関数
<LI>文字列を作るための関数
<LI>文字列から変換するための関数
</UL>

を持つ．
</P>

<DT><A NAME="cmdproc">コマンドプロシージャ</A>
<DD><P>
ユーザ定義コマンドの実体．C(またはC++)言語で書かれた関数で，次の形をし
ている．

<PRE>
typedef int Tcl_ObjCmdProc(ClientData clientData, Tcl_Interp* interp,
                           int objc,
                           Tcl_Obj* const objv[]);
</PRE>

clientData はユーザが勝手に使って良いデータで，コマンド登録時に設定し
た値がコマンド起動時にこの関数に渡される．
たとえば異なるコマンドを同じコマンドプロシージャで処理するときなどに，
処理対象を区別するために用いることができる．
また，Tkのウィジェットコマンドなどでは個々のウィジェットを指定するため
にこのclientDataが用いられる．
interpはインタプリタ，objcとobjv[]で引数を表している．
</P>

<DT><A NAME="trace">トレースコールバック</A>
<DD><P>
Tcl変数に対してアクセスしたときに自動的に起動される関数．
C(またはC++)言語で書かれた関数で，次の形をし
ている．

<PRE>
typedef char* Tcl_VarTraceProc(ClientData clientData, Tcl_Interp* interp,
                               char* part1, char* part2, int flags);
</PRE>

clientData はコマンドプロシージャ同様にユーザが勝手に使って良いデータ
で，トレース設定時に設定した値がコールバック時にこの関数に渡される．
使い方はユーザ次第だが，たとえば，Tcl変数に結び付けたいCの内部データへ
のポインタ等を入れておくことが多い．
</P>

</DL>

</body>

</html>